Habr: [gRPC: лучше ли этот фреймворк, чем REST API? / Хабр (habr.com)](https://habr.com/ru/companies/nix/articles/594391/)
Habr: [RPC на примере gRPC. Когда применять и как работает / Хабр (habr.com)](https://habr.com/ru/articles/787164/)

---

`Remote Procedure Call` (RPC) – это протокол взаимодействия между клиентом и сервером, который позволяет клиенту вызывать процедуры (функции, методы) на удаленном сервере, как если бы они были локальными. Это обеспечивает абстракцию взаимодействия по сети и позволяет программам работать в распределенной среде, скрывая сложности передачи данных и выполнения удаленных операций.

#### Основные компоненты RPC

- Клиент: Программа или компонент, инициирующий вызов удаленной процедуры.

- Сервер: Программа или компонент, предоставляющий методы, которые могут быть вызваны удаленно.

- Прокси: Клиент использует прокси-объект для вызова удаленных процедур на сервере, как если бы они были локальными.

- Сериализация: процесс преобразования данных и параметров процедур в формат, который может быть передан через сеть (например, в формат JSON, бинарный формат и т. д.).

- Транспорт: механизм передачи сериализованных данных между клиентом и сервером, например, http.

- IDL (Interface Definition Language): Язык определения интерфейса, который определяет структуру и сигнатуры удаленных процедур.

Протокол `RPC` позволяет разработчикам вызывать функции или методы на удаленных серверах таким образом, что код клиента выглядит так, как будто вызовы происходят локально. Процессы сериализации и десериализации обеспечивают преобразование данных между форматами, понятными клиенту и серверу.

Преимущества `RPC` включают простоту использования, удобство абстракции и возможность вызова удаленных процедур, не заботясь о деталях взаимодействия по сети.

## Что такое gRPC?

`gRPC` - это фреймворк, т.е. достаточно комплексное решение. На данный момент он отправляет данные по протоколу [[HTTP|HTTP2]]. На просторах `github` есть попытки в `HTTP3`, но эти решения не пользуются большой популярностью.

`gRPC` реализует своё виденье [[HTTP|HTTP2]]. Обычно поверх него не добавляются шифрование в виде протокола [[TLS, SSL|TLS]], однако при необходимости его можно добавить.

Передача данных идет в бинарном формате. Данных получается меньше, они более оптимизированы, чем тот же `JSON` (весь `JSON` объект будет приведен в символы ASCII для передачи, что влечёт за собой передача неоптимальных и ненужных байтов). Сериализация проходит в бинарную систему для более оптимальной передачи.


## Виды использования RPC в целом и gRPC в частности. 

**Унарный — Unary RPC, 1—1.** Синхронный запрос клиента, который блокируется, пока не будет получен ответ от сервера. Клиент ничего не может сделать до получения ответа или пока запрос не упадет по таймауту.

![Унарный RPC](https://habrastorage.org/r/w1560/getpro/habr/upload_files/1af/770/08e/1af77008ebcb3574dd748e155ec9d67c.png "Унарный RPC")


**Клиентский стрим — Client streaming RPC, N—1.** При подключении сервера клиент начинает стримить сообщения на него. _Клиент делает запрос на сервер в виде последовательности N сообщений и получает ответ в виде одного сообщения от сервера._

![Клиентский стрим](https://habrastorage.org/r/w1560/getpro/habr/upload_files/4cd/004/b82/4cd004b82557ebc1fd2e1d837d8ffcd3.png "Клиентский стрим")


**Серверный стрим —  Server streaming RPC, 1—N.** При подключении клиента сервер открывает стрим и начинает отправлять сообщения. Клиент делает запрос на сервер в виде одного сообщения и получает ответ в виде последовательности N сообщений от сервера.

![Серверный стрим](https://habrastorage.org/r/w1560/getpro/habr/upload_files/c36/82a/7fc/c3682a7fcece7bc966ab2a886f82db6a.png "Серверный стрим")


**Двунаправленный стрим — Bidirectional streaming, N—N.** Клиент инициализирует соединение, создаются два стрима. В общем случае клиент делает запрос на сервер в виде последовательности N сообщений и получает ответ в виде последовательности N сообщений от сервера. Сервер может отправить изначальные данные при подключении или отвечать на каждый запрос клиента по типу пинг-понга. Два потока работают независимо, поэтому клиенты и серверы могут читать и писать в любом порядке. Например, сервер может дождаться получения всех клиентских сообщений, прежде чем записывать свои ответы, или он может поочередно читать сообщения, а затем сразу писать на них ответы. Возможна и какая-то другая комбинация чтения и записи. Порядок сообщений в каждом потоке сохраняется.

![Двунаправленный стрим](https://habrastorage.org/r/w1560/getpro/habr/upload_files/c45/bcb/eba/c45bcbebaec45c89a91d5892b65cb88c.png "Двунаправленный стрим")

## Возможности gRPC

Кратко структурируем возможности `gRPC`, которые хорошо используют функционал [[HTTP|HTTP2]].

1. Протокол-независимая сериализация:
	- По умолчанию используется `Protocol Buffers` (`ProtoBuf`) для сериализации данных.
	- Возможна поддержка других форматов сериализации, таких как `JSON`.

2. Поддержка множества языков:
	- `gRPC` поддерживает множество языков программирования, включая C++, Java, Python, Go, Ruby, C#, Node.js, и многие другие.

3. Одновременные запросы (`Multiplexing`):
	- Позволяет отправлять несколько запросов и получать несколько ответов одновременно на одном соединении.

4. Streaming:
	- Поддерживает как однонаправленный, так и двунаправленный поток данных.
	- Клиенты и серверы могут отправлять последовательности сообщений.

5. Автоматическая генерация кода:
	- Генерация клиентского и серверного кода на основе описания API в proto файле (`Protocol Buffers`).

6. Сжатие данных:
	- Возможность сжимать данные для уменьшения объема трафика.

7. Поддержка [[TLS, SSL|TLS / SSL]]:
	- Возможность обеспечивать безопасную передачу данных с использованием `SSL/TLS`.

8. Библиотека метаданных:
	- Возможность отправлять и получать метаданные в заголовках запросов.

9. Отмена запросов:
	- Клиенты могут отменять отправленные запросы, что особенно полезно в асинхронных сценариях.

10. `gRPC`-заголовки:
	- Поддержка кастомизированных заголовков для передачи дополнительной информации.

11. Дополнительные аутентификационные механизмы:
	- Поддержка аутентификации с использованием токенов и других механизмов.

12. gRPC Web:
	- Возможность использовать `gRPC` в веб-браузерах с использованием gRPC Web.

13. Средства мониторинга и трассировки:
	- Интеграция с инструментами мониторинга, такими как Prometheus, и трассировки, такими как Jaeger.

14. Встроенная поддержка статусов:
	- Поддержка стандартных и пользовательских кодов статуса.


> Для работы с `gRPC` в C# можно использовать `Grpc.Net`. Интегрируется с ASP.NET Core. Потребуется определить сервисы и сообщения с использованием `protobuf`.


