Illustrated TLS connection : [The Illustrated TLS Connection: Every Byte Explained (xargs.org)](https://tls12.xargs.org/#server-certificate/annotated)

---

Проблема протокола [[HTTP|HTTP]] в том, что данные передаются по сети в **открытом незашифрованном виде**. Это позволяет злоумышленнику слушать передаваемые пакеты и извлекать любую информацию из параметров, заголовков и тела сообщения. Для устранения уязвимости был разработан `HTTPS` (S в конце значит Secure) - он, хоть не является отдельным протоколом, всего лишь [[HTTP|HTTP]] поверх SSL (а позже `TLS`), позволяет безопасно обмениваться данными. В отличие от [[HTTP|HTTP]] со стандартным портом 80, для `HTTPS` используется порт 443.

## SSL

`Secure Sockets Layer` (SSL) - это криптографический протокол, обеспечивающий безопасное общение пользователя и сервера по небезопасной сети. Располагается между транспортным уровнем и уровнем программы-клиента. Впервые был представлен публике в 1995 году, однако с 2015 года признан полностью устаревшим. На основе спецификации `SSL 3.0` в 1996 был разработан `TLS 1.0`.

## TLS

**Transport Layer Security** - это развитие идей, заложенных в протоколе SSL. Протокол обеспечивает услуги: 
- приватности (сокрытие передаваемой информации), 
- целостности (обнаружение изменений), 
- аутентификации (проверка авторства). 
>Достигаются они за счет гибридного шифрования, то есть совместного использования `ассиметричного` и `симметричного` шифрования.

`Симметричное шифрование` предполагает наличие общего ключа одновременно у отправителя и получателя, с помощью которого происходит шифровка и дешифровка данных. Данный тип не требователен к ресурсам, однако существенно страдает безопасность из-за опасности кражи ключа злоумышленником.

При использовании `ассиметричного шифрования` существует открытый ключ, который можно свободно распространять, и закрытый ключ, который держится в секрете у одной из сторон. Этот тип работает медленно, относительно симметричного шифрования, однако скомпрометировать закрытый ключ сложнее.

Чтобы решить проблему производительности (шифровать ассиметрично абсолютно все - сложно), в `TLS` используется **гибридное шифрование**: общий ключ для симметричного шифрования данных передается от клиента серверу зашифрованным открытым ключом сервера, после этого сервер может его расшифровать своим закрытым ключом и использовать для обмена данными с клиентом. Давайте разберем подробнее и по порядку, каким образом работает TLS соединение.

## Что происходит на практике

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/a12/7f8/d5d/a127f8d5dc9ee67d155349186453e34a.png)

#### 1. **Client Hello** 
Клиент начинает общение с сервером отсылая информацию о предпочитаемой версии протокола `TLS`, набора поддерживаемых шифров (`Cipher Spec`), и случайного простого числа (client random), необходимого в дальнейшем для генерации общего ключа симметричного шифрования.
   
>Что такое `Cipher Spec`? 

В процессе установки соединения, клиент и сервер должны договориться о: 
- какой алгоритм использовать для обмена ключами (например, `RSA` - Риверт-Шамир-Адлеман, `DH` - Диффи-Хеллмана, `ECDH` - Диффи-Хеллмана на эллиптических кривых, и др.), 
- какой алгоритм использовать для шифрования данных (`AES` - Advanced Encryption Standard, `3DES` - Triple Data Encryption Algorithm, и др.), 
- какую криптографическую хэш-функцию использовать для генерации Message Authentication Code (`SHA-256`, `SHA-384`, `SHA-512` - Secure Hash Algorithm с соответствующей длиной строки в битах с хэшем, и др.).

>Что такое `Message Authentication Code` или `MAC`?

 Это хэш, сгенерированный с использованием выбранной криптографической хэш-функции и разделяемого ключа, который добавляется сзади к сообщению. Перед отправкой данных отправитель вычисляет `MAC` для них, а получатель перед обработкой вычисляет `MAC` для принятого сообщения и сравнивает его с `MAC` этого принятого сообщения. Предназначен для проверки целостности, то есть что сообщение не было изменено при его передаче.

#### 2. **Server Hello** 
Сервер отвечает выбранной версией протокола и выбранным из предложенного набора шифром, которые будут непосредственно использоваться, своим случайным простым числом (server random) и идентификатором сессии.

>**Для чего нужен идентификатор сессии?** 

Как мы посмотрим далее, процесс установления `TLS` соединения затратен по времени и ресурсам. Предусмотрен механизм возобновления соединения с помощью отправки клиентом этого идентификатора. Если сервер тоже все еще хранит соответствующие настройки, то клиент и сервер смогут продолжить общение использую ранее выбранные алгоритмы и ключи.

#### 3. **Certificate** 
Сервер отправляет свой сертификат, а клиент производит проверку подписи удостоверяющего центра, проверку доверия к удостоверяющему центру, проверку указанного домена сайта с фактическим, срока действия, проверяет не был ли сертификат отозван.
   
>**Что представляет из себя сертификат?** 

`Сертификат` - это открытый ключ и другая информация о его владельце, а также Электронная Цифровая Подпись (`ЭЦП`) доверенного центра.
   
**Как работает ЭЦП?** При создании `ЭЦП` хэш данных, которые подписываются, шифруется закрытым ключом, в отличие от обычного ассиметричного шифрования, где зашифровка выполняется открытым ключом. Таким образом, если вам удалось расшифровать открытым ключом хэш, и он оказался идентичен хэшу из данных, - вы можете быть уверены что: подпись была сделана именно владельцем приватного ключа, открытый ключ которого вы используете; данные, которые были подписаны, не изменились с момента подписания.

>**Как удостовериться, что открытый ключ принадлежит не злоумышленнику?

Существуют корневые удостоверяющие центры (`Root Certificate Authority` или просто `CA` - Certificate Authority), которым доверяют все участники обмена информацией. Если в цепочке подписания сертификата сервера есть подпись корневого `CA` (мы можем проверить ее с помощью `открытого ключа` `CA`), то мы можем ему доверять. При этом сертификаты (открытые ключи) корневых `CA` распространяются посредством включения их в операционную систему или браузер поставщиками. Также стоит отметить, что сертификат может быть подписан сертификатом, который подписан в свою очередь другим сертификатом - это цепочка подписания.
   
>**Кем подписан сертификат корневого CA?** 

А никем, нет инстанции выше корневого CA. Сертификат (открытый ключ) в этом случае подписан собственным закрытым ключом. Такие сертификаты называют `самоподписанные` (sefl-signed).
   
#### 4. **Server Key Exchange** 
Этот этап происходит не всегда, только если необходимы дополнительные данные для создания симметричного ключа при выбранном алгоритме. Например, при обмене ключами `RSA` этот шаг пропускается и для обмена общим ключ передается от клиента серверу зашифрованным открытым ключом сервера из его сертификата. Однако в этой статье рассмотрим более надежный **алгоритм `Диффи-Хеллмана`**. 

Пример:
    - Сервер случайно генерирует число 6, передает клиенту числа `p` = 17, `g` = 3,` Ys` = 36mod 17 = 15
    - Клиент случайно генерирует число 7 и возвращает серверу `Yc` = 37mod 17 = 11
    - Сервер считает итоговое число 116mod 17= 8, и клиент 157mod 17 = 8

#### **Server Hello Done** 
 Сервер сообщает, что начальный этап установки соединения завершен
 
#### 6. **Client Key Exchange** 
Как было уже сказано выше, когда сервер передал числа `p`, `g`, `Ys` в `Server Key Echange`, клиент передает свое число `Yc` в `Client Key Exchange`. Вычисленное в конце общее одинаковое число используется для создания `pre-master secret` - предварительного разделяемого ключа. На основании `client random`, `server random` и `pre-master secret` псевдослучайная функция выдает симметричный ключ и ключ вычисления `MAC`. Таким образом клиент и сервер имеют все необходимое для начала обмена полезной информацией.

#### 7. **Change Cipher Spec** 
Клиент говорит серверу, что он готов перейти на защищенное соединение.

#### 8. **Finished** 
Клиент зашифровывает симметричным ключом первое сообщение с `MAC`.

#### 9. **Change Cipher Spec**
Сервер проверяет сообщение Finished от клиента и отправляет в ответ свою готовность к защищенному соединению.

#### 10. **Finished**
Аналогично клиенту, сервер отправляет тестовое зашифрованное сообщение

#### 11. 
После этого **соединение считается установленным**, и происходит передача полезной информации

#### 12. **Close_notify** 
Служебное сообщение, которое одна сторона отправляет другой, как уведомление о том, что **считает** **соединение разорванным** и не будет принимать больше сообщения. Другая сторона в ответ обязана послать аналогичное сообщение `close_notify`.

## Двусторонний TLS

Двусторонний `TLS` или `Two Way TLS` или `mutual TLS` (`mTLS`) означает проверку сертификата клиента. Сервер после своего сообщения `Certificate` посылает запрос сертификата клиента `CertificateRequest`. Клиент в ответ отправляет `Certificate`, сервер производит проверку, аналогичную проверке сертификата сервера клиентом. Далее настройка `TLS` происходит в описанном выше порядке.

## TLS v1.3

Стоит отметить, что все выше написанное относится к **TLSv1.2**, которая начинает понемногу устаревать. В 2018 году была разработана **новая версия 1.3** в которой: были запрещены уже ненадежные алгоритмы, ускорен процесс соединения, переработан протокол рукопожатия и др. Интернет медленно но верно обновляется до TLSv1.3, однако все еще большинство сайтов работают по протоколу TLSv1.2. Поэтому информация остается актуальной.
