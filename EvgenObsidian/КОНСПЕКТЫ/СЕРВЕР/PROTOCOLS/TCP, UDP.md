Habr: [TCP и UDP, или Два столпа Интернета / Хабр (habr.com)](https://habr.com/ru/articles/711578/)
Habr: [Протоколы семейства TCP/IP. Теория и практика / Хабр (habr.com)](https://habr.com/ru/companies/ruvds/articles/759988/)

---

Транспортный уровень [[Эталонная модель TCP IP|модели TCP/IP]] основан на двух китах: `Transmission Control Protocol` и `User Datagram Protocol`. Есть и другие протоколы на этом уровне, но они не так часто используются.

Протоколы транспортного уровня используются для адресации пакетов с порта приложения отправителя на порт приложения получателя. Более того, протоколы этого уровня не знают ничего про различия в узлах сетей. Всё, что им требуется знать про адресацию, это то, что есть приложение, отсылающее сообщение, и оно для отправки использует какой-то порт. И приложение, которое получает сообщение, тоже использует какой-то порт. 

`UDP` куда «легче» и проще, чем `TCP`, но в то же время `UDP` не такой надёжный.

### UDP (User Datagram Protocol)

Этот протокол используется для «связи без установки соединения» _(connectionless communication_ – _пер.)._ Один узел сети просто отсылает пакеты, адресуя их другому узлу. Отправитель не знает ничего о том, готов ли получатель к приёму пакетов, и вообще, существует ли этот получатель. Отправитель также не ждёт какого-либо подтверждения о том, что получатель принял предыдущие пакеты.

Пакеты, передаваемые с помощью `UDP`, иногда называются `датаграммами`. Этот термин обычно используется тогда, когда важно подчеркнуть, что пакет передаётся без установки соединения.

Заголовок `UDP-пакета` состоит из 8 байт, которые включают в себя:

- порт отправителя;
- порт получателя;
- длину датаграммы;
- контрольную сумму.

Типичная UDP-датаграмма выглядит так:

![Payload – это полезная нагрузка; сообщение, которое датаграмма должна передать получателю](https://habrastorage.org/r/w1560/getpro/habr/upload_files/94d/e78/156/94de78156f2e5d4603c22fb0395b0943.png "Payload – это полезная нагрузка; сообщение, которое датаграмма должна передать получателю")

Payload – это полезная нагрузка; сообщение, которое датаграмма должна передать получателю

### TCP (Transmission Control Protocol)

Если `UDP` простой и не требующий установки соединения, то `TCP` – сложный и требующий. Перед тем, как начать передачу данных, клиент и сервер должны подключиться друг к другу и договориться о том, как они будут осуществлять эту самую передачу.

В отличие от датаграмм в `UDP`, пакеты, создаваемые `TCP`, называются сегментами.

Задачи, которые решает `TCP` во время передачи данных:

- Убеждается в том, что сегменты доставлены в нужном порядке.
- Убеждается в том, что они вообще доставлены.
- Контролирует поток пакетов, чтобы не перегружать им узлы сети.

Заголовок у `TCP` как минимум 20 байт, но как правило больше. Он включает в себя:

- порт отправителя;
- порт получателя;
- порядковый номер;
- номер подтверждения;
- длину заголовка;
- флаги;
- размер окна;
- контрольную сумму;
- указатель важности;
- дополнительные опции.    

Схема пакета выглядит так:

![Набор опций может меняться, как и их итоговый размер](https://habrastorage.org/r/w1560/getpro/habr/upload_files/2d2/917/081/2d2917081ec1e6a8dc94d9b0d037d8f7.png "Набор опций может меняться, как и их итоговый размер")

Набор опций может меняться, как и их итоговый размер

Порт отправителя, порт получателя и контрольная сумма – такие же поля, как и в UDP.

### Рукопожатие

Прежде, чем клиент начнёт посылать данные серверу, они оба должны установить соединение. Эта «установка» обычно называется `рукопожатием`.

Как правило рукопожатие происходит в три этапа:

1. Клиент посылает серверу пакет, который называется `SYN`.
2. Сервер отвечает пакетом `SYN-ACK`.
3. Клиент отвечает серверу пакетом `ACK`.

Названия пакетов взяты из названий флагов, которые установлены в TCP-заголовках этих пакетов. Вот как первый из пакетов рукопожатия выглядит в Wireshark:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/1b8/758/72c/1b875872ca054c2c0f4ad8f5a816b8e0.png)

Один из битовых флагов установлен в 1. Флаг называется «Syn», что есть сокращение от «Синхронизация».

`TCP` – надёжный протокол, что означает, что отправитель всегда в курсе, дошёл ли пакет до получателя или нет. Чтобы сделать такое уведомление возможным, `TCP` использует специальные типы пакетов (`SYN`, `ACK` и пр.), а также каждый `TCP-заголовок` содержит два числа: порядковый номер и номер подтверждения.

`Порядковый номер` _(Sequence number_ – _пер.)_ показывает, сколько данных отправитель уже послал в сторону получателя. Этот номер увеличивается на 1 каждый раз, когда отправитель посылает пакеты с флагами `SYN` или `FIN`, а также увеличивается на размер полезных данных, если они были переданы. Число, указанное в номере, не учитывает текущий пакет. А потому порядковый номер первого пакета, посылаемого клиентом, всегда равен 0.

`Номер подтверждения` _(Acknowledgement number_ – _пер.)_ же показывает сколько данных отправитель этого пакета получил на текущий момент. Это число как бы отзеркаливает порядковый номер «собеседника», но опережает его на один шаг. А потому первый пакет, отправленный сервером, имеет номер подтверждения равный 1.

_Вообще, начальные значения для этих номеров выбираются случайным образом. Но для простоты обычно оперируют их относительными значениями.

Эти числа важны, потому что позволяют обеим сторонам понимать статус передачи данных. И клиент, и сервер, оба ожидают получить определённые значения порядкового номера и номера подтверждения от противоположной стороны. А если вдруг действительно полученные значения расходятся с ожидаемыми, значит где-то произошла ошибка, и возможно кто-то из них должен переотправить какие-то пакеты.

Когда рукопожатие закончено, наш сервер как раз и понимает, что клиент готов передавать данные, и начинает их от него ожидать.

### Передача данных

Когда рукопожатие закончено, начинается передача данных.

![Пример сегмента с данными в логе Wireshark](https://habrastorage.org/r/w1560/getpro/habr/upload_files/7a5/3c6/819/7a53c6819b98943c302de22f9e3fd5c7.png "Пример сегмента с данными в логе Wireshark")
Пример сегмента с данными в логе Wireshark

Как видно в логе выше, каждый кусок данных отправленный одной стороной, подтверждён _(ACK-ed_ – _пер.)_ отдельным сегментом, отправленным другой стороной.

### Завершение соединения

Когда один из «собеседников» решает прекратить общение, он инициирует завершение соединения. Этот процесс похож на рукопожатие, но вместо флага `SYN` используется флаг `FIN`.

Вот как выглядит завершение соединения в логе:

![Две пары FIN-ACK- и ACK-сегментов](https://habrastorage.org/r/w1560/getpro/habr/upload_files/fb7/312/a70/fb7312a70ba725c47cc2b7c5606c2e07.png "Две пары FIN-ACK- и ACK-сегментов")

Для завершения соединения потребовалось четыре сегмента, а не три, как в случае с рукопожатием. Схема выглядит чуть иначе, потому что при завершении соединения, собеседник (в нашем случае сервер) должен сперва уведомить приложение, использующее `TCP`, о том, что соединение вот-вот завершится. И когда это приложение будет готово к завершению, тогда `TCP` собеседника отправит свой `FIN-пакет`.

_Иногда завершение соединения вызывается не сегментом с флагом `FIN`, а сегментом с флагом `RST`. Это не совсем обычная практика, то такое возможно. Также `RST-флаг` может быть использован для атаки, которая может прервать существующее соединение между `TCP-узлами`._
