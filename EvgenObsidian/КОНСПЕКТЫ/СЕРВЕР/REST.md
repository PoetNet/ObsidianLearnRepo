Habr: [Введение в REST API — RESTful веб-сервисы / Хабр (habr.com)](https://habr.com/ru/articles/483202/)
Habr: [REST, что же ты такое? Понятное введение в технологию для ИТ-аналитиков / Хабр (habr.com)](https://habr.com/ru/articles/590679/)

---

**REST** (Representational State Transfer — архитектурный стиль взаимодействия компонентов распределённого приложения в сети. Другими словами, `REST` — это набор правил того, как программисту организовать написание кода серверного приложения, чтобы все системы легко обменивались данными и приложение можно было масштабировать. `REST` представляет собой согласованный набор ограничений, учитываемых при проектировании распределённой гипермедиа-системы.

## Ресурс

`Ресурс` — это ключевая абстракция, на которой концентрируется протокол [[HTTP|HTTP]]. `Ресурс` — это все, что вы хотите показать внешнему миру через ваше приложение. Например, если мы пишем приложение для управления задачами, экземпляры ресурсов будут следующие:  

- Конкретный пользователь
- Конкретная задача
- Список задач
#### URI ресурса

При разработке `RESTful` сервисов, необходимо сосредоточить свое внимание на ресурсах приложения. Способ, которым идентифицируется ресурс для предоставления, состоит в том, чтобы назначить ему `URI` — универсальный идентификатор ресурса. Например:  
  
- Создать пользователя: **POST /users**
- Удалить пользователя: **DELETE /users/1**
- Получить всех пользователей: **GET /users**
- Получить одного пользователя: **GET /users/1**

## Принципы REST

Рассмотри **6 принципов** `REST` — ограничений, которые и помогают нам добиться этих нефункциональных требований.

1. [[Клиент-серверная архитектура|Клиент-серверная архитектура]]
2. Stateless
3. Кэширование
4. Единообразие интерфейса
5. Layered system
6. Code on demand

#### Принцип 1. Клиент-серверная архитектура

**_Что дает клиент-серверная архитектура и зачем она нужна?_**

Во-первых, клиент-серверная архитектура дает нам определённую масштабируемость: есть сервер, есть единая точка обработки запросов. При необходимости выдерживать большую нагрузку мы можем поставить несколько серверов. Также к нему можно подключать достаточно большое количество клиентов (сколько сможет выдержать). Таким образом, **клиент-серверная архитектура позволяет добиться масштабируемости.**

Во-вторых, `REST` даёт определённую простоту поддержки. Если мы хотим изменить логику обработки информации на сервере, то выполним эти изменения на сервере. В данном случае мы можем и не менять каждого клиента, как если бы они были абсолютно равноценной сетью.

Конечно, есть и минусы. В случае с клиент-серверной архитектурой мы понимаем, что у нас есть единая точка отказа в виде сервера. Если отказал сервер и у нас нет дополнительных инстансов, то для нас это будет означать неработоспособность системы.

Также потенциально может увеличиться нагрузка, поскольку часть логики мы вынесли с клиента на сервер. Клиент будет совершать меньше каких-либо действий самостоятельно, соответственно, у нас возрастёт количество запросов между клиентом и сервером.

#### Принцип 2. Stateless

Принцип заключается в том, что сервер не должен хранить у себя информацию о сессии с клиентом. Он должен в каждом запросе получать всю информацию для обработки.

>Какие он даёт плюсы?
- Масштабируемость сервера,
- Уменьшение времени обработки запроса,
- Простота поддержки,
- Возможность использовать кэширование.

В первую очередь, это масштабирование сервера. Если каждый запрос содержит в себе абсолютно весь контекст, необходимый для обработки, то можно, например, клонировать сервер-обработчик: вместо одного поставить десять таких. Мне будет абсолютно неважно, в какой из этих клонов придёт запрос. Если бы они хранили состояние, то либо должны были синхронизироваться, либо мне нужно было бы умело направлять запрос в нужное место.

>Какие проблемы может создать Stateless-подход?
- Усложнение логики клиента (именно на стороне клиента нам нужно хранить всю информацию о состоянии, о допустимых действиях, о недопустимых действиях и подобных вещах).
- Увеличение нагрузки на сеть (каждый раз мы передаём всю информацию, весь контекст. Таким образом, больше информации гоняем по сети).

#### Принцип 3. Кэширование

>Какие у кэширования плюсы?
- Уменьшение количества сетевых взаимодействий.
- Уменьшение нагрузки на системы (не грузим их дополнительными запросами).

При этом важно понимать, что кэширование — это совсем не простая штука. Она бывает достаточно сложна и нетривиальна в реализации.  
Также мы должны учитывать, что если отдаём какие-то данные, которые сохранили раньше, то важно помнить, что эти данные могли уже устареть.

#### Принцип 4. Единообразие интерфейса. HATEOAS

Hypermedia as the Engine of Application State (`HATEOAS`) — одно из ограничений `REST`, согласно которому сервер возвращает не только ресурс, но и его связи с другими ресурсами и действия, которые можно с ним совершить.

Здесь мы используем `HTTP-глагол` GET, то есть хотим получить ресурс. Обращаемся к некоторому счёту с номером 12345. 

Что же предлагает `HATEOAS`? Если бы мы с учётом этого ограничения выполняли бы этот запрос, то в ответе получим не только информацию об этом объекте, но и все те действия, которые мы можем с ним совершить. И, если бы у него были бы какие-то важные связанные объекты, мы получили бы ещё и ссылки на них.  

![Пример ответа с использованием принципа HATEOAS](https://habrastorage.org/r/w1560/getpro/habr/upload_files/eff/a5a/0ef/effa5a0efbe600988caa50477b4cad44.png "Пример ответа с использованием принципа HATEOAS")
Пример ответа с использованием принципа `HATEOAS`

>Главный плюс этого подхода — клиент становится очень гибким в плане изменений на сервере с точки зрения изменения допустимых действий, изменения модели данных и т.д.

>В качестве обратной стороны медали мы получаем сильное усложнение логики, в первую очередь, клиента. Это может потянуть за собой и усложнение логики на сервере, потому что такие ответы нужно правильно формировать. Фактически ответственность за действия, которые совершает клиент, мы передаём на его же сторону. Мы ослабляем контроль валидности совершаемых операций на стороне сервера.

#### Принцип 5. Layered system (слоистая архитектура)

Концепция слоистой архитектуры заключается в том, что ни клиент, ни сервер не должны знать о том, как происходит цепочка вызовов дальше своих прямых соседей.

>Минусы:
- Увеличение нагрузки на сеть (больше участников и больше вызовов, чем если бы мы шли один раз от клиента до сервера напрямую).
- Увеличение времени получения ответа (из-за появления дополнительных участников).

#### Принцип 6. Code on done (код по требованию)

Идея передачи некоторого исполняемого кода (по сути какой-то программы) от сервера клиенту.

## **Преимущества REST-архитектуры:**

1. **Простота:** `REST` использует стандартные `HTTP-методы` и легко понимаемые структуры данных, что делает его простым для разработчиков.
2. **Масштабируемость:** `RESTful` сервисы могут быть легко масштабированы, так как они не хранят состояние между запросами.
3. **Гибкость:** Клиенты и серверы взаимодействуют через стандартные протоколы и форматы, что обеспечивает гибкость и возможность изменения без воздействия на другие компоненты системы.
4. **Кэширование:** `REST` поддерживает кэширование данных, что может существенно улучшить производительность.
