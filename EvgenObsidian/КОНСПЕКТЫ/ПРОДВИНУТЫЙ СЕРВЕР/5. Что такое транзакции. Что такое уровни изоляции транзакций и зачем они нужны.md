
Транзакция представляет собой последовательность операций базы данных, которые должны быть выполнены как единое целое. Транзакция либо выполняется полностью, успешно завершаясь (commit), либо откатывается (rollback), возвращая базу данных к состоянию, предшествующему началу транзакции. Транзакции играют ключевую роль в обеспечении целостности данных и сохранности базы данных в случае ошибок или сбоев.

Уровни изоляции транзакций определяют, как одна транзакция видит изменения, сделанные другими транзакциями, которые еще не завершены (или зафиксированы). Они контролируют степень изоляции между параллельными транзакциями и определяют, какие виды аномалий при доступе к данным могут возникнуть в многопользовательской среде. Вот некоторые из наиболее распространенных уровней изоляции транзакций:

1. **READ UNCOMMITTED (Чтение незафиксированных данных):** Это самый низкий уровень изоляции, при котором транзакция может видеть изменения, сделанные другими транзакциями, которые еще не завершены. Это может привести к таким проблемам, как "грязное чтение" (dirty read), когда транзакция читает данные, которые позже будут отменены другой транзакцией.

2. **READ COMMITTED (Чтение зафиксированных данных):** Этот уровень изоляции позволяет транзакциям видеть только изменения, которые были зафиксированы (committed) другими транзакциями. Однако это не исключает таких аномалий, как "неповторяющееся чтение" (non-repeatable read) или "фантомное чтение" (phantom read).

3. **REPEATABLE READ (Повторяемое чтение):** В этом уровне изоляции транзакция видит только данные, которые были зафиксированы на момент начала транзакции, что исключает проблему "неповторяющегося чтения". Однако могут возникать проблемы с "фантомным чтением".

4. **SERIALIZABLE (Сериализуемое чтение):** Это самый высокий уровень изоляции, при котором транзакции видят данные так, будто они выполняются последовательно, без параллельных изменений. Это гарантирует, что не возникнет ни одна известная аномалия, но может привести к блокировкам и ухудшению производительности.

Выбор уровня изоляции зависит от требований к целостности данных и производительности приложения. Более высокий уровень изоляции обычно обеспечивает большую надежность, но может повысить вероятность блокировок и конфликтов при параллельном доступе к данным.

## Блокировка транзакций.

Блокировка транзакций (или просто блокировка) - это механизм, используемый в базах данных для контроля доступа к ресурсам и обеспечения целостности данных. Она предотвращает конфликты и гарантирует, что несколько транзакций не могут одновременно изменять одни и те же данные. Блокировки могут быть установлены на различные уровни, включая строки, таблицы, страницы и даже базы данных целиком.

#### 1. **Оптимистическая блокировка:**

Оптимистическая блокировка предполагает, что конфликтов не будет, и позволяет нескольким транзакциям работать с данными одновременно. Однако при сохранении изменений EF Core проверяет, не были ли данные изменены другими транзакциями с момента извлечения их текущей транзакцией. Если обнаружены изменения, то возникает исключение `DbUpdateConcurrencyException`, и приложение может принять соответствующие действия.
  
```C#
using Microsoft.EntityFrameworkCore;  

var entity = await context.Entities.FindAsync(id); 
if (entity != null) 
{
	entity.Property = newValue;      
	try     
	{
	         await context.SaveChangesAsync();
	}     
	catch (DbUpdateConcurrencyException)
	{
		// Обработка конфликтов     
	} 
}
```

#### 2. **Пессимистическая блокировка:**
   
Пессимистическая блокировка предполагает, что конфликты могут возникнуть, поэтому она явно блокирует ресурсы для изменения другими транзакциями до завершения текущей транзакции. В EF Core пессимистическая блокировка может быть реализована с помощью метода `FromSqlRaw` или `FromSqlInterpolated`, позволяющего выполнить SQL-запрос с явным указанием блокировки.

```C#
using Microsoft.EntityFrameworkCore;  
var entity = await context.Entities
	.FromSqlRaw("SELECT * FROM Entities WITH (UPDLOCK, ROWLOCK) WHERE Id = {0}", id)
    .FirstOrDefaultAsync();  
if (entity != null) 
{
	entity.Property = newValue;
	await context.SaveChangesAsync(); 
}
```

Здесь `UPDLOCK` указывает на блокировку записи для обновления, а `ROWLOCK` - на блокировку по строкам.